# 树与二叉树
## 二叉树的后序非递归遍历
```c++
int main() {
    //先构造一棵树
    TreeNode *root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);
    root->right->left = new TreeNode(6);
    root->right->right = new TreeNode(7);

    stack<TreeNode *> s;
    TreeNode *cur = root;
    //r记录上一个遍历过的节点
    TreeNode *r = nullptr;
    while (cur || !s.empty()) {
        //把所有的左子树都放到栈里
        if (cur) {
            s.push(cur);
            cur = cur->left;
        } else {
            //cur为当前栈顶元素，即遍历过的树中最左面的节点
            cur = s.top();
            //如果当前节点有右子树，并且右子树还没有走过
            //因为对于一个节点的后序遍历来说，他的上一个节点
            //是他的右子树，所以要遍历右子树时，只需要看他有没有走过
            if (cur->right && cur->right != r) {
                //如果没有走过，自然继续放右子树
                cur = cur->right;
                s.push(cur);
                cur = cur->left;
            } else {
                s.pop();
                //访问节点
                cout<<cur->val<<endl;
                //更新r
                r = cur;
                cur = nullptr;
            }
        }
    }
}
```
## 通过二叉树后序非递归遍历找到一个节点的祖先
这里需要知道，通过后序非递归遍历到指定节点x时，此时栈中的元素都是x的祖先。
```c++
int main() {
    TreeNode *root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);
    root->right->left = new TreeNode(6);
    root->right->right = new TreeNode(7);

    //正常栈
    stack<TreeNode *> s;
    //用来存放节点x的祖先
    stack<TreeNode *> s2;
    stack<TreeNode *> s3;
    TreeNode *cur = root;
    TreeNode *r = nullptr;
    while (cur || !s.empty()) {
        if (cur) {
            s.push(cur);
            cur = cur->left;
        } else {
            cur = s.top();
            if (cur->right && cur->right != r) {
                cur = cur->right;
                s.push(cur);
                cur = cur->left;
            } else {
                s.pop();
                //此时遍历到了指定的节点
                //记录s当前的栈内的内容
                if (cur->val == 5) {
                    //把s1的放到s3
                    while (!s.empty()) {
                        TreeNode *t = s.top();
                        s.pop();
                        s3.push(t);
                    }
                    //再把s3放到s1，顺便放到s2里面
                    while (!s3.empty()) {
                        TreeNode *t = s3.top();
                        s3.pop();
                        s.push(t);
                        s2.push(t);
                    }
                }
                r = cur;
                cur = nullptr;
            }
        }
    }
    cout << "5那个节点的祖先是" << endl;
    while (!s2.empty()) {
        TreeNode *t = s2.top();
        s2.pop();
        cout << t->val << endl;
    }

}
```
## 通过二叉树后序非递归遍历，找到给定的两个节点的最近公共祖先
有了上面一个节点的祖先路径的基础，就可以利用后序非递归遍历，拿到两个节点的祖先路径(此时在两条路径存储在两个栈里)，自然可以得到最近的公共祖先，也可以得到公共祖先路径。
```c++
class Solution {
public:
    TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {
        //正常用来递归的栈
        stack<TreeNode *> s1;
        //用来保存p的祖先路径的栈
        stack<TreeNode *> s2;
        //用来保存q的祖先路径的栈
        stack<TreeNode *> s3;
        //保存祖先路径时需要的辅助栈
        stack<TreeNode *> temp;

        TreeNode *cur = root;
        TreeNode *r = nullptr;
        while (cur || !s1.empty()) {
            if (cur) {
                s1.push(cur);
                cur = cur->left;
            } else {
                cur = s1.top();
                if (cur->right && cur->right != r) {
                    cur = cur->right;
                    s1.push(cur);
                    cur = cur->left;
                } else {
                    s1.pop();
                    //如果遍历到了p，那么此时s1里面的节点都是p的祖先
                    //然后用s2保存
                    if (cur == p) {
                        //把s1里面的值放到temp里面
                        while (!s1.empty()) {
                            TreeNode *t = s1.top();
                            s1.pop();
                            temp.push(t);
                        }
                        while (!temp.empty()) {
                            TreeNode *t = temp.top();
                            temp.pop();
                            s1.push(t);
                            s2.push(t);
                        }
                        //因为自己的祖先可能是自己，所以这里
                        //在保存路径的地方存储上自己
                        s2.push(cur);
                    }
                    if (cur == q) {
                        while (!s1.empty()) {
                            TreeNode *t = s1.top();
                            s1.pop();
                            temp.push(t);
                        }
                        while (!temp.empty()) {
                            TreeNode *t = temp.top();
                            temp.pop();
                            s1.push(t);
                            s3.push(t);
                        }
                        //同理，在q的祖先路径上存储自己
                        s3.push(cur);
                    }
                    r = cur;
                    cur = nullptr;
                }
            }
        }
        //让两个栈的长度一样长
        while (s3.size() > s2.size())
            s3.pop();
        while (s3.size() < s2.size())
            s2.pop();

        //祖先路径从下往上找，找到第一个相同的节点就行
        while (!s3.empty() && !s2.empty()) {
            if (s3.top() == s2.top())
                return s3.top();
            s3.pop();
            s2.pop();
        }
        return root;
    }
};
```