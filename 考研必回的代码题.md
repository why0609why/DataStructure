# 树与二叉树
## 二叉树的后序非递归遍历
```c++
int main() {
    //先构造一棵树
    TreeNode *root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);
    root->right->left = new TreeNode(6);
    root->right->right = new TreeNode(7);

    stack<TreeNode *> s;
    TreeNode *cur = root;
    //r记录上一个遍历过的节点
    TreeNode *r = nullptr;
    while (cur || !s.empty()) {
        //把所有的左子树都放到栈里
        if (cur) {
            s.push(cur);
            cur = cur->left;
        } else {
            //cur为当前栈顶元素，即遍历过的树中最左面的节点
            cur = s.top();
            //如果当前节点有右子树，并且右子树还没有走过
            //因为对于一个节点的后序遍历来说，他的上一个节点
            //是他的右子树，所以要遍历右子树时，只需要看他有没有走过
            if (cur->right && cur->right != r) {
                //如果没有走过，自然继续放右子树
                cur = cur->right;
                s.push(cur);
                cur = cur->left;
            } else {
                s.pop();
                //访问节点
                cout<<cur->val<<endl;
                //更新r
                r = cur;
                cur = nullptr;
            }
        }
    }
}
```