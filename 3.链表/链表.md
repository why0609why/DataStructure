# 链表
- 真正的动态结构
- 长度不需要担心
- 使用了递归 

# 关于链表的dummyhead
只是单纯的为了链表整体性的遍历的方便。
比如说在链表的add(int index)和get(int index)这两个操作中
1. add操作需要遍历到索引为index-1的位置上的节点,那么就从dummyhead的位置向后遍历index次(这个很好想,因为从dummyhead开始,向后走一次到了索引为0的节点,向后走两次就走到了索引为1的节点,那么向后走index次,就到了index-1的节点,自然就是到了add需要到达的节点的位置)
2. get操作需要直接遍历到索引为index的节点,那么自然就是从dummyhead.next开始遍历index次就行了。因为移动一次是到索引为1的节点,那么移动index次自然就是移动到索引为index的节点了。


# 链表的时间复杂度分析
- 添加操作
  - addFirst(e) O(1)
  - addLast(e) O(n)
  - add(index,e) O(n)   
- 删除操作
  - removeFirst() O(1)
  - removeLast() O(n)
  - remove(index) O(n)      如果只对链表头进行增添和操作,就是O(1)的操作


# 链表实现栈
因为链表对于表头的增添和删除都是O(1)的操作,所以把表头当作栈顶


# 链表实现队列
用一个头指针和一个尾指针用来实现队列,因为在有尾指针的前提下在尾部进行插入是O(1)的,而且在头部删除也是O(1)的,所以这里采用在尾部插入,头部删除来实现队列

为什么有了尾指针在末尾进行删除还是O(n)呢？这个很简单,因为最后一个节点是需要前一个节点的,所以要找到倒数第二个节点还是得O(n)操作,所以在结尾使用增添，来两个O(1)实现队列