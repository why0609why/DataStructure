# 集合(Set)的复杂度分析
因为用二分搜索树和链表都能实现Set，而且一个是树型，一个是线型，所以这里分析这两种底层来分析集合的复杂度

链表： 增加：O(n)  查O(n)  删除O(n)
二分搜索树： 因为每次都是根据层来遍历的，所以 增加O(log n)  查询O(log n) 删除O(log n) 

注意二分搜索树可能会退化成链表，所以上面说的二分搜索树的复杂度是平均来讲的。最差的情况复杂度也是O(n)，这个效率和链表一样.
而且准确的来讲，二分搜索树的时间复杂度应该是O(h)，h是BST的高度，大部分情况h = log N ，最坏情况下h = n.


# 映射(Map)的复杂度分析
用BST和链表都能实现映射，所以和上面一样，这里也来分析一下这两个的时间复杂度
链表： 增加：O(n)  查O(n)  删除O(n)
二分搜索树： 因为每次都是根据层来遍历的，所以 增加O(log n)  查询O(log n) 删除O(log n) 

注意二分搜索树可能会退化成链表，所以上面说的二分搜索树的复杂度是平均来讲的。最差的情况复杂度也是O(n)，这个效率和链表一样.
而且准确的来讲，二分搜索树的时间复杂度应该是O(h)，h是BST的高度，大部分情况h = log N ，最坏情况下h = n.


可以发现用链表实现集合和链表实现映射都是O(n)操作的，用BST实现的都是O(h)操作的。而且BST最差会转换成链表。为了解决这个BST的最坏问题，后期会引入平衡二叉树的概念。

# 用链表实现set
用链表实现set完全就是链表的逻辑，也可以直接那链表做底层结构为上层的set接口提供方法，直接调用链表的方法就能实现set。

# 用BST实现set
同链表实现set，用BST实现set也是完全调用BST的接口。不过应该知道TreeSet的底层是平衡二分搜索树，HashSet的底层是哈希表。

# 用链表实现map
和原来的逻辑差不多，只不过把链表的内部类型节点类型的值变成了键值对，也就实现了一个节点绑定一个键值对，然后其他的增删改查操作和原来的链表一样。

# 用BST实现map
同链表实现map，用BST实现map也是把节点的内部类的值变成了键值对，因为BST是二分搜索树，带有比较的，所以节点的key需要继承Comparable接口。剩下的逻辑和正常的BST一样。